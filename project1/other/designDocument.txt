//DATA STRUCTURES:


1. Tracking unprocessed pages:
The PageQueue class will implement a Linked-list containing type Page, which is a class that stores a page's URL and it's description. Since there won't need to be any traversal done on this list (it simulates a queue in that the only functionality necessary is enqueue() and dequeue()), an linked-list is suitable because it can contain any type, and accessing/removing the first element and adding a new element are O(1) operations (constant). I choose a linked-list over an array because an array must be declared a certain size initially, thereby giving a chance that the link will inordinately big or too small. A linked-list can grow or shrink very easily.

2. Tracking already processed pages
The PageHistory class will use a BST containing type Page. Unlike the PageQueue class, the PageHistory BST needs to be traversed many times to ensure that the WebCrawler does not revisit pages that have already be encountered and enter an infinite loop, making use of the Find method we've already established in earlier projects. Traversal on a BST is generally faster than a regular linked-list or array and, like the PageQueue, this data structure needs to be able to scale well. Insertion into the list is O(log n), slower than a Linked-list, but what is lost in insertion is gained in traversal.

3. Managing stop words
The StopWords class will store the ordered list of words (type string) found in the stopword file in an array of string. It will be O(n) to insert each word found in the the text file into the array, but average O(log n) to search for the specific stop word when comparing the index of words found to the contents of the array of string StopWords contains because, thanks to the guaranteed sorted order of the file, the traversal can be done using a binary search. Determining the exactly the correct size of the array in StopWords would make it necessary to parse through the list initially before storage O(n), but since it would only need to be traversed this way once and then be usable for comparing throughout the duration of the program, this is worth the extra step.

4. Storing word/page index
The WordIndex class will implement a map from words to their respective OccurenceSet. WordIndex itself is binary search three where each BSTNode contains a Word object. Each Word object stores the value of the string and its OccurenceSet. An OccurenceSet is also a binary search tree where each BSTNode contains an Occurrence object, and each Occurrence object contains the URL the word was found on and an int variable that contains the number of times the word appeared on that page. This way, WordIndex is really a BST that contains objects that contain their own BST's. A BST works well because I will need to store or update words as I find them, and although this BST implementation won't be self-balancing, the chances of it being quicker to traverse/iterate over in order to find the appropriate word than a linked-list or array is high. Each OccurenceSet object contains a BST as well INCLUDE WHY IMPORTANT. A binary search tree is favorable because it scales well (versus an array, which involves a fairly complicated/error prone process of creating and copying into a new larger array every time the original array is full).
